<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Slime Soccer - Unit Tests</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .test-container {
            background: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .test-result {
            margin: 10px 0;
            padding: 10px;
            border-radius: 4px;
            font-weight: bold;
        }
        .test-pass {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .test-fail {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .test-summary {
            font-size: 18px;
            margin: 20px 0;
            padding: 15px;
            border-radius: 8px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        h1 {
            color: #333;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }
        h2 {
            color: #666;
            margin-top: 30px;
        }
        .run-tests-btn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 16px;
            cursor: pointer;
            margin: 20px 0;
        }
        .run-tests-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
    </style>
</head>
<body>
    <h1>üß™ Slime Soccer - Unit Tests</h1>
    
    <div class="test-container">
        <p>This test suite validates the core game logic and systems of Slime Soccer.</p>
        <button class="run-tests-btn" onclick="runAllTests()">üöÄ Run All Tests</button>
        <div id="test-results"></div>
    </div>

    <script>
        /**
         * Simple testing framework for game validation
         */
        class TestRunner {
            constructor() {
                this.tests = [];
                this.results = [];
            }

            addTest(name, testFn) {
                this.tests.push({ name, testFn });
            }

            assert(condition, message) {
                if (!condition) {
                    throw new Error(message || 'Assertion failed');
                }
            }

            assertEqual(actual, expected, message) {
                if (actual !== expected) {
                    throw new Error(message || `Expected ${expected}, got ${actual}`);
                }
            }

            assertNotNull(value, message) {
                if (value === null || value === undefined) {
                    throw new Error(message || 'Value should not be null or undefined');
                }
            }

            async runTests() {
                this.results = [];
                
                for (const test of this.tests) {
                    try {
                        await test.testFn();
                        this.results.push({ name: test.name, passed: true, error: null });
                    } catch (error) {
                        this.results.push({ name: test.name, passed: false, error: error.message });
                    }
                }

                this.displayResults();
            }

            displayResults() {
                const container = document.getElementById('test-results');
                const passed = this.results.filter(r => r.passed).length;
                const total = this.results.length;

                let html = `
                    <div class="test-summary">
                        üìä Test Results: ${passed}/${total} tests passed
                        ${passed === total ? 'üéâ All tests passed!' : '‚ö†Ô∏è Some tests failed'}
                    </div>
                `;

                this.results.forEach(result => {
                    const cssClass = result.passed ? 'test-pass' : 'test-fail';
                    const icon = result.passed ? '‚úÖ' : '‚ùå';
                    html += `
                        <div class="test-result ${cssClass}">
                            ${icon} ${result.name}
                            ${result.error ? `<br><small>Error: ${result.error}</small>` : ''}
                        </div>
                    `;
                });

                container.innerHTML = html;
            }
        }

        // Initialize test runner
        const testRunner = new TestRunner();

        // --- Utility Function Tests ---
        testRunner.addTest('Utility Functions - clamp', () => {
            // Mock utility functions for testing
            const clamp = (n, min, max) => Math.max(min, Math.min(max, n));
            
            testRunner.assertEqual(clamp(5, 0, 10), 5, 'clamp should return value when within range');
            testRunner.assertEqual(clamp(-5, 0, 10), 0, 'clamp should return min when below range');
            testRunner.assertEqual(clamp(15, 0, 10), 10, 'clamp should return max when above range');
        });

        testRunner.addTest('Utility Functions - lerp', () => {
            const lerp = (a, b, t) => a + (b - a) * t;
            
            testRunner.assertEqual(lerp(0, 10, 0.5), 5, 'lerp should interpolate correctly');
            testRunner.assertEqual(lerp(0, 10, 0), 0, 'lerp should return start value at t=0');
            testRunner.assertEqual(lerp(0, 10, 1), 10, 'lerp should return end value at t=1');
        });

        // --- Game Logic Tests ---
        testRunner.addTest('Game Initialization', () => {
            // Create a mock canvas element for testing
            const mockCanvas = document.createElement('canvas');
            mockCanvas.id = 'game';
            mockCanvas.width = 960;
            mockCanvas.height = 600;
            document.body.appendChild(mockCanvas);

            // Create mock DOM elements
            const mockElements = ['menu', 'ui', 'legend', 'powerIndicator', 'fx-root', 'touchpad', 'time', 'p1s', 'p2s', 'errorMessage'];
            mockElements.forEach(id => {
                const el = document.createElement('div');
                el.id = id;
                document.body.appendChild(el);
            });

            testRunner.assertNotNull(document.getElementById('game'), 'Game canvas should exist');
            testRunner.assertNotNull(mockCanvas.getContext('2d'), 'Canvas should have 2D context');
        });

        testRunner.addTest('Physics Constants Validation', () => {
            // Test physics constants are within reasonable ranges
            const gravity = 0.5;
            const friction = 0.85;
            const bounceDecay = 0.8;

            testRunner.assert(gravity > 0 && gravity < 2, 'Gravity should be realistic (0-2)');
            testRunner.assert(friction > 0 && friction <= 1, 'Friction should be 0-1');
            testRunner.assert(bounceDecay > 0 && bounceDecay <= 1, 'Bounce decay should be 0-1');
        });

        testRunner.addTest('Entity Boundaries', () => {
            // Test entity positioning within canvas bounds
            const canvasWidth = 960;
            const canvasHeight = 600;
            const playerRadius = 40;
            const ballRadius = 15;

            // Test player boundaries
            const player1X = 160;
            const player2X = canvasWidth - 160;
            
            testRunner.assert(player1X - playerRadius > 0, 'Player 1 should be within left boundary');
            testRunner.assert(player2X + playerRadius < canvasWidth, 'Player 2 should be within right boundary');
            
            // Test ball center position
            const ballCenterX = canvasWidth / 2;
            testRunner.assert(ballCenterX > ballRadius && ballCenterX < canvasWidth - ballRadius, 
                'Ball should start within canvas bounds');
        });

        testRunner.addTest('AI Difficulty Settings', () => {
            // Test AI difficulty configuration
            const difficulties = {
                easy: {speed: 0.7, jump: 0.015, track: 0.8, react: 0.9},
                normal: {speed: 1.2, jump: 0.035, track: 1.1, react: 1.0},
                hard: {speed: 1.7, jump: 0.065, track: 1.5, react: 1.3},
                expert: {speed: 2.0, jump: 0.08, track: 1.8, react: 1.6}
            };

            Object.keys(difficulties).forEach(level => {
                const config = difficulties[level];
                testRunner.assert(config.speed > 0, `${level} AI speed should be positive`);
                testRunner.assert(config.jump > 0, `${level} AI jump should be positive`);
                testRunner.assert(config.track > 0, `${level} AI tracking should be positive`);
                testRunner.assert(config.react > 0, `${level} AI reaction should be positive`);
            });

            // Test difficulty progression
            testRunner.assert(difficulties.easy.speed < difficulties.normal.speed, 
                'Easy should be slower than normal');
            testRunner.assert(difficulties.normal.speed < difficulties.hard.speed, 
                'Normal should be slower than hard');
            testRunner.assert(difficulties.hard.speed < difficulties.expert.speed, 
                'Hard should be slower than expert');
        });

        testRunner.addTest('Collision Detection Logic', () => {
            // Test collision detection calculations
            const calculateDistance = (x1, y1, x2, y2) => Math.hypot(x2 - x1, y2 - y1);
            
            const player = { x: 100, y: 100, r: 40 };
            const ball = { x: 120, y: 120, r: 15 };
            
            const distance = calculateDistance(player.x, player.y, ball.x, ball.y);
            const colliding = distance < player.r + ball.r;
            
            testRunner.assert(distance > 0, 'Distance should be positive');
            testRunner.assert(colliding, 'Entities should be colliding at close distance');
            
            // Test non-colliding entities
            const farBall = { x: 200, y: 200, r: 15 };
            const farDistance = calculateDistance(player.x, player.y, farBall.x, farBall.y);
            const notColliding = farDistance >= player.r + farBall.r;
            
            testRunner.assert(notColliding, 'Distant entities should not be colliding');
        });

        testRunner.addTest('Power-up System', () => {
            // Test power-up effects and durations
            const powerUpTypes = ['speed', 'jump', 'bigball'];
            const now = performance.now();
            
            testRunner.assert(powerUpTypes.length === 3, 'Should have exactly 3 power-up types');
            
            // Test power-up duration logic
            const speedPower = { type: 'speed', until: now + 5000 };
            const isActive = now < speedPower.until;
            
            testRunner.assert(isActive, 'Power-up should be active when current time is before expiry');
            
            // Test expired power-up
            const expiredPower = { type: 'jump', until: now - 1000 };
            const isExpired = now >= expiredPower.until;
            
            testRunner.assert(isExpired, 'Power-up should be expired when current time is after expiry');
        });

        testRunner.addTest('Screen Shake System', () => {
            // Test screen shake decay
            let screenShake = 15;
            const decayRate = 0.3;
            
            // Simulate multiple frames
            for (let i = 0; i < 10; i++) {
                screenShake = Math.max(0, screenShake - decayRate);
            }
            
            testRunner.assert(screenShake >= 0, 'Screen shake should never go below 0');
            testRunner.assert(screenShake < 15, 'Screen shake should decay over time');
        });

        testRunner.addTest('Memory Management', () => {
            // Test particle system memory management
            let particles = [];
            const maxParticles = 100;
            
            // Add more particles than the limit
            for (let i = 0; i < 150; i++) {
                particles.push({ id: i, life: 20 });
            }
            
            // Simulate memory management
            if (particles.length > maxParticles) {
                particles = particles.slice(-maxParticles);
            }
            
            testRunner.assertEqual(particles.length, maxParticles, 
                'Particle count should be limited to prevent memory issues');
            testRunner.assertEqual(particles[0].id, 50, 
                'Oldest particles should be removed first');
        });

        // Global test runner function
        function runAllTests() {
            testRunner.runTests();
        }

        // Auto-run tests when page loads
        document.addEventListener('DOMContentLoaded', () => {
            console.log('üß™ Test framework loaded. Click "Run All Tests" to validate the game.');
        });
    </script>
</body>
</html>