<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Slime Soccer ‚Äì Hyper Edition (Stabilized + Patched)</title>
  <style>
    * { box-sizing: border-box; }
    html, body { margin: 0; height: 100%; }
    body {
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      min-height: 100vh;
      display: grid;
      place-items: center;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      overflow: hidden;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }

    .game-container { position: relative; width: 100vw; height: 100vh; display: grid; place-items: center; }

    canvas {
      border: 4px solid rgba(255,255,255,.25);
      border-radius: 16px;
      box-shadow: 0 24px 60px rgba(0,0,0,.35);
      background: linear-gradient(to bottom, #87CEEB 0%, #98FB98 100%);
      max-width: 98vw;
      max-height: 82vh;
    }

    .ui-overlay {
      position: absolute; inset: 0 auto auto 0; right: 0; height: 64px;
      display: flex; align-items: center; justify-content: space-between; gap: 16px;
      padding: 12px 16px; color: #fff; z-index: 30;
      background: linear-gradient(to bottom, rgba(0,0,0,.35), rgba(0,0,0,.1));
      backdrop-filter: blur(6px);
    }
    .score { font-weight: 800; font-size: clamp(18px, 3vw, 28px); letter-spacing:.5px; text-shadow: 0 3px 12px rgba(0,0,0,.55); }
    .timer { font-weight: 700; font-size: clamp(16px, 2.6vw, 24px); opacity:.95 }
    .controls-hint { font-size: clamp(12px, 1.8vw, 14px); opacity:.9 }
    .btn {
      background: rgba(255,255,255,.15); color: #fff; border: 0; border-radius: 999px;
      padding: 10px 16px; cursor: pointer; font-weight: 600; box-shadow: 0 6px 18px rgba(0,0,0,.25);
      transition: transform .15s ease, box-shadow .15s ease, background .2s ease;
    }
    .btn:hover { transform: translateY(-1px); box-shadow: 0 10px 28px rgba(0,0,0,.35); }

    .menu {
      position: absolute; inset: 0; display: grid; place-items: center; z-index: 50;
      background: radial-gradient(60% 60% at 50% 35%, rgba(255,255,255,.18) 0%, rgba(0,0,0,.25) 100%);
      backdrop-filter: blur(10px);
    }
    .panel {
      width: min(760px, 92vw); border-radius: 20px; padding: 28px; background: rgba(255,255,255,.96);
      box-shadow: 0 24px 60px rgba(0,0,0,.35);
    }
    h1 { margin: 0 0 12px; font-size: clamp(24px, 4.6vw, 42px); line-height: 1.1;
      background: linear-gradient(45deg, #667eea, #764ba2); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
    .subtitle { color: #333; opacity: .8; margin-bottom: 20px; }

    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 14px; margin-block: 8px; }
    .row label { font-weight: 700; color: #333; font-size: 14px; }
    .row select { width: 100%; padding: 12px 14px; border-radius: 12px; border: 1px solid #e6e6e6; font-weight: 600; }

    .menu-actions { display: flex; flex-wrap: wrap; gap: 10px; margin-top: 16px; }
    .start-btn { background: linear-gradient(45deg, #667eea, #764ba2); color: #fff; padding: 14px 22px; border-radius: 14px; border: 0; font-weight: 800; letter-spacing:.2px; cursor: pointer; }

    .hidden { display: none !important; }

    /* Winner / Goal messages */
    .toast {
      position: absolute; left: 50%; top: 18%; transform: translate(-50%, -50%) scale(.9);
      background: rgba(255, 215, 0, .98); color: #333; padding: 18px 26px; border-radius: 16px;
      font-weight: 900; font-size: clamp(18px, 4.4vw, 38px); z-index: 45; box-shadow: 0 18px 46px rgba(0,0,0,.35);
      animation: pop .45s ease forwards;
    }
    @keyframes pop { 0% { transform: translate(-50%, -50%) scale(0); } 60% { transform: translate(-50%, -50%) scale(1.06);} 100% { transform: translate(-50%, -50%) scale(1);} }

    .flash { position: absolute; inset: 0; background: radial-gradient(60% 60% at 50% 50%, rgba(255,255,255,.9), transparent 60%); z-index: 40; animation: flash .45s ease; pointer-events: none; }
    @keyframes flash { from { opacity: .95; } to { opacity: 0; } }

    /* Power-ups indicator */
    .power-indicator {
      position: absolute; top: 70px; left: 16px; z-index: 25; color: #fff; font-weight: 700; font-size: 12px;
      background: rgba(0,0,0,.35); padding: 6px 10px; border-radius: 8px; backdrop-filter: blur(4px);
      transition: opacity .3s ease;
    }

    /* Enhanced legend */
    .legend { position: absolute; bottom: 8px; left: 50%; transform: translateX(-50%); z-index: 25; color: #fff; font-weight: 700; font-size: 12px; background: rgba(0,0,0,.35); padding: 6px 10px; border-radius: 999px; }

    /* Enhanced mobile controls */
    .touchpad { position: absolute; inset: auto 0 16px 0; display: flex; justify-content: space-between; padding: 0 12px; z-index: 35; }
    .dpad, .apad { display: flex; gap: 10px; }
    .tbtn {
      width: 64px; height: 64px; border-radius: 50%; border: 0; background: rgba(255,255,255,.22);
      box-shadow: 0 8px 22px rgba(0,0,0,.35); color: #fff; font-weight: 900; font-size: 18px; cursor: pointer;
      touch-action: none; transition: all .15s ease;
    }
    .tbtn:active { transform: scale(.95); background: rgba(255,255,255,.35); }
    @media (min-width: 981px) { .touchpad { display: none; } }

    /* Combo indicator */
    .combo-indicator {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      color: #ff6b35; font-weight: 900; font-size: 24px; z-index: 35;
      text-shadow: 0 3px 12px rgba(0,0,0,.7); opacity: 0;
      animation: combo-pop .8s ease forwards;
    }
    /* BUGFIX: missing closing brace for keyframes */
    @keyframes combo-pop { 
      0% { opacity: 0; transform: translate(-50%, -50%) scale(.5); } 
      30% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); } 
      100% { opacity: 0; transform: translate(-50%, -50%) scale(1) translateY(-30px); } 
    }

    /* Error message */
    .error-message {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      background: rgba(255, 0, 0, 0.9); color: white; padding: 20px;
      border-radius: 10px; z-index: 100; display: none;
    }
  </style>
</head>
<body>
  <div class="game-container">
    <div class="menu" id="menu">
      <div class="panel">
        <h1>üü¢ SLIME SOCCER ‚öΩ Hyper Edition</h1>
        <div class="subtitle">Yeni oyun modlarƒ±, power-up'lar ve yer √ßekimi ayarlarƒ±yla!</div>
        <div class="row">
          <label>Oyun Modu</label>
          <select id="modeSelect">
            <option value="single">üë§ Tek Ki≈üilik (Yapay Zekaya Kar≈üƒ±)</option>
            <option value="soccer" selected>üë• ƒ∞ki Ki≈üilik</option>
          </select>
        </div>
        <div class="row">
          <label>Yer √áekimi</label>
          <select id="gravitySelect">
            <option value="normal" selected>Normal</option>
            <option value="low">D√º≈ü√ºk Yer √áekimi</option>
            <option value="high">Y√ºksek Yer √áekimi</option>
          </select>
        </div>
        <div class="row" id="difficultyRow">
          <label>Zorluk (AI)</label>
          <select id="difficultySelect">
            <option value="easy">Kolay</option>
            <option value="normal" selected>Normal</option>
            <option value="hard">Zor</option>
            <option value="expert">Uzman</option>
          </select>
        </div>
        <div class="row">
          <label>Tema</label>
          <select id="themeSelect">
            <option value="stadium" selected>Stadyum</option>
            <option value="beach">Plaj</option>
            <option value="space">Uzay</option>
            <option value="neon">Neon</option>
            <option value="retro">Retro</option>
          </select>
        </div>
        <div class="menu-actions">
          <button class="start-btn" id="startBtn">üéÆ Oyunu Ba≈ülat</button>
          <button class="btn" id="howBtn">üìò Kontroller</button>
        </div>
      </div>
    </div>

    <div class="ui-overlay hidden" id="ui">
      <div class="score"><span id="p1s">0</span> ‚Äì <span id="p2s">0</span></div>
      <div class="timer">‚è±Ô∏è <span id="time">90</span>s</div>
      <div class="controls-hint">P1: A/D/W ‚Ä¢ P2: ‚Üê/‚Üí/‚Üë</div>
      <div style="display:flex; gap:8px; align-items:center">
        <button class="btn" id="pauseBtn">‚è∏Ô∏è Duraklat</button>
        <button class="btn" id="restartBtn">üîÑ Sƒ±fƒ±rla</button>
      </div>
    </div>

    <canvas id="game" width="960" height="600" class="hidden"></canvas>

    <div class="power-indicator hidden" id="powerIndicator">Aktif G√º√ßler: Yok</div>
    <div class="legend hidden" id="legend">Power-up'lar: ‚ö° Hƒ±z ‚Ä¢ ü¶ò Zƒ±plama ‚Ä¢ üéØ Dev Top</div>

    <div class="touchpad hidden" id="touchpad">
      <div class="dpad">
        <button class="tbtn" id="p1Left">‚óÄ</button>
        <button class="tbtn" id="p1Right">‚ñ∂</button>
      </div>
      <div class="apad">
        <button class="tbtn" id="p1Jump">‚§¥</button>
      </div>
    </div>

    <div class="error-message" id="errorMessage">
      Oyun hatasƒ±! Yeniden ba≈ülatƒ±lƒ±yor...
    </div>

    <div id="fx-root"></div>
  </div>

  <script>
  // --- Enhanced Audio Synth with Error Handling
  const Sound = (() => {
    let ctx;
    try {
      ctx = new (window.AudioContext || window.webkitAudioContext)();
    } catch (e) {
      console.warn("Audio context not available:", e);
      return {
        kick: () => {}, goal: () => {}, power: () => {}, click: () => {},
        bounce: () => {}, combo: () => {}, freeze: () => {}, fire: () => {},
        goalFanfare: () => {}
      };
    }

    function beep(freq=440, dur=0.08, type='square', gain=0.05, fadeOut=true){
      try {
        if (!ctx || ctx.state === 'closed') return;
        const o = ctx.createOscillator();
        const g = ctx.createGain();
        o.type = type;
        o.frequency.value = freq;
        g.gain.value = gain;
        if (fadeOut) g.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + dur);
        o.connect(g).connect(ctx.destination);
        o.start();
        o.stop(ctx.currentTime + dur);
      } catch (e) {
        console.warn("Audio error:", e);
      }
    }

    return {
      kick(){ beep(120, .08, 'sine', .12); setTimeout(()=>beep(80,.05,'sine',.06), 40); },
      goal(){ beep(880,.25,'square',.1); setTimeout(()=>beep(660,.3,'square',.08), 150); setTimeout(()=>beep(440,.35,'square',.06), 300); },
      power(){ beep(520,.15,'triangle',.08); setTimeout(()=>beep(780,.1,'sine',.05), 80); },
      click(){ beep(420,.04,'triangle',.04); },
      bounce(){ beep(300,.03,'sine',.03); },
      combo(){ beep(660,.12,'triangle',.07); setTimeout(()=>beep(880,.1,'triangle',.05), 60); },
      freeze(){ beep(200,.2,'sawtooth',.06); },
      fire(){ beep(800,.15,'square',.07); setTimeout(()=>beep(600,.1,'square',.05), 80); },
      goalFanfare(){ 
        const melody = [880, 1046.5, 1318.5, 1568];
        melody.forEach((f, i) => setTimeout(() => beep(f, .15, 'square', .1, true), i * 150));
      }
    }
  })();

  // --- Helpers
  const clamp=(n,mi,ma)=>Math.max(mi,Math.min(ma,n));
  const rand=(a,b)=>Math.random()*(b-a)+a;
  const lerp=(a,b,t)=>a+(b-a)*t;

  class Game {
    constructor(){
      // Error handling
      this.errorCount = 0;
      this.maxErrors = 5;
      this.lastErrorTime = 0;
      
      // Timer management - improved
      this.activeTimeouts = new Map();
      this.timeoutIdCounter = 0;
      this.animationFrameId = null;
      this.isRunning = false;

      try {
        this.initializeGame();
      } catch (e) {
        this.handleError("Constructor error", e);
      }
    }

    initializeGame() {
      // DOM elements with null checks
      this.canvas = document.getElementById('game');
      this.ctx = this.canvas?.getContext('2d');
      this.menu = document.getElementById('menu');
      this.ui = document.getElementById('ui');
      this.legend = document.getElementById('legend');
      this.powerIndicator = document.getElementById('powerIndicator');
      this.fxRoot = document.getElementById('fx-root');
      this.touchpad = document.getElementById('touchpad');
      this.timeEl = document.getElementById('time');
      this.p1sEl = document.getElementById('p1s');
      this.p2sEl = document.getElementById('p2s');
      this.errorEl = document.getElementById('errorMessage');

      if (!this.canvas || !this.ctx) {
        throw new Error("Canvas initialization failed");
      }

      // Game settings
      this.mode = 'soccer';
      this.theme = 'stadium';
      this.gravitySetting = 'normal';
      this.setDifficulty('normal');

      // Physics
      this.gravity = 0.5;
      this.friction = 0.85;
      this.bounceDecay = 0.8;

      // Initialize entities
      this.resetEntities();

      // Game state
      this.state = 'menu';
      this.score = {p1:0, p2:0};
      this.timeLeft = 90;
      this.keys = {};
      this.particles = [];
      this.ballTrail = [];
      this.powerUps = [];
      this.lastSpawn = 0;
      this.winningScore = 5;
      this.lastScoredPlayer = null;
      this.frameCount = 0;

      // Enhanced features
      this.combo = {p1: 0, p2: 0};
      this.lastHit = {player: null, time: 0};
      this.screenShake = 0;

      // Initialize controls
      this.bindKeys();
      this.bindUI();
      this.resizeForMobile();
      
      // Visibility change handler (BUGFIX: store reference so we can remove later)
      this._onVisibilityChange = () => {
        if (document.hidden && this.state === 'playing') {
          this.togglePause();
        }
      };
      document.addEventListener('visibilitychange', this._onVisibilityChange);
    }

    // --- Improved Error Handling ---
    handleError(context, error) {
      console.error(`${context}:`, error);
      this.errorCount++;
      this.lastErrorTime = Date.now();
      
      if (this.errorEl) {
        this.errorEl.textContent = `Hata: ${context}`;
        this.errorEl.style.display = 'block';
        this.createTimeout(() => {
          if (this.errorEl) this.errorEl.style.display = 'none';
        }, 3000);
      }

      if (this.errorCount >= this.maxErrors) {
        this.emergencyReset();
      }
    }

    emergencyReset() {
      console.warn("Emergency reset triggered");
      this.clearAllTimers();
      this.state = 'menu';
      this.errorCount = 0;
      
      // Show menu, hide game elements
      try {
        if (this.menu) this.menu.classList.remove('hidden');
        if (this.ui) this.ui.classList.add('hidden');
        if (this.canvas) this.canvas.classList.add('hidden');
      } catch (e) {
        console.error("Error in emergency reset:", e);
      }
    }

    // --- Improved Timer Management ---
    createTimeout(callback, delay) {
      const id = ++this.timeoutIdCounter;
      const safeDelay = Math.min(Math.max(delay, 0), 10000); // 0-10s range
      
      const timeoutId = setTimeout(() => {
        if (this.activeTimeouts.has(id)) {
          this.activeTimeouts.delete(id);
          try {
            callback();
          } catch (e) {
            this.handleError("Timeout callback error", e);
          }
        }
      }, safeDelay);
      
      this.activeTimeouts.set(id, timeoutId);
      
      // Prevent memory leak - max 20 timeouts
      if (this.activeTimeouts.size > 20) {
        const firstKey = this.activeTimeouts.keys().next().value;
        const firstTimeout = this.activeTimeouts.get(firstKey);
        clearTimeout(firstTimeout);
        this.activeTimeouts.delete(firstKey);
      }
      
      return id;
    }

    clearTimeout(id) {
      if (this.activeTimeouts.has(id)) {
        clearTimeout(this.activeTimeouts.get(id));
        this.activeTimeouts.delete(id);
      }
    }

    clearAllTimers() {
      // Clear all timeouts
      for (const [id, timeoutId] of this.activeTimeouts) {
        clearTimeout(timeoutId);
      }
      this.activeTimeouts.clear();
      
      // Cancel animation frame
      if (this.animationFrameId) {
        cancelAnimationFrame(this.animationFrameId);
        this.animationFrameId = null;
      }
      
      this.isRunning = false;
    }

    // --- Simplified Game Loop ---
    startLoop() {
      if (this.isRunning) return;
      this.isRunning = true;
      this.frameCount = 0;
      this.loop();
    }

    loop = () => {
      if (!this.isRunning || this.state !== 'playing') {
        this.isRunning = false;
        return;
      }

      try {
        this.update();
        this.render();
        this.frameCount++;
        
        // Reset frame counter periodically to prevent overflow
        if (this.frameCount > 100000) {
          this.frameCount = 0;
        }
      } catch (e) {
        this.handleError("Game loop error", e);
        return;
      }

      // Continue loop
      this.animationFrameId = requestAnimationFrame(this.loop);
    }

    // --- Game State Methods ---
    start(mode='soccer', gravity='normal', diff='normal', theme='stadium'){
      try {
        this.clearAllTimers();
        
        // Validate canvas context
        if (!this.ctx || this.ctx.canvas.width === 0) {
          throw new Error("Invalid canvas context");
        }
        
        this.mode = mode; 
        this.gravitySetting = gravity;
        this.setDifficulty(diff); 
        this.theme = theme;
        
        // UI updates with null checks
        this.menu?.classList.add('hidden');
        this.ui?.classList.remove('hidden');
        this.legend?.classList.remove('hidden');
        this.powerIndicator?.classList.remove('hidden');
        this.canvas?.classList.remove('hidden');
        
        // Reset game state
        this.state = 'playing'; 
        this.score = {p1:0, p2:0}; 
        this.timeLeft = 90; 
        this.combo = {p1:0, p2:0}; 
        this.powerUps = [];
        this.particles = [];
        this.ballTrail = [];
        this.lastScoredPlayer = null;
        this.errorCount = 0; // Reset error count
        
        this.resetEntities();
        this.applyTheme();
        this.setGameRules();
        
        // Update score display
        if (this.p1sEl) this.p1sEl.textContent = '0';
        if (this.p2sEl) this.p2sEl.textContent = '0';
        if (this.timeEl) this.timeEl.textContent = '90';
        
        this.startLoop();
        
      } catch (e) {
        this.handleError("Start game error", e);
      }
    }

    restart(){
      this.start(this.mode, this.gravitySetting, this.difficulty, this.theme);
    }

    togglePause(){
      try {
        if(this.state === 'playing'){ 
          this.state = 'paused';
          this.isRunning = false;
          if (this.animationFrameId) {
            cancelAnimationFrame(this.animationFrameId);
            this.animationFrameId = null;
          }
          this.toast('Duraklatƒ±ldƒ± ‚è∏Ô∏è', 700); 
        } else if (this.state === 'paused') { 
          this.state = 'playing'; 
          this.toast('Devam! ‚ñ∂Ô∏è', 600); 
          this._lastTime = performance.now();
          this.startLoop();
        }
      } catch (e) {
        this.handleError("Pause error", e);
      }
    }

    endGame(){
      if(this.state !== 'playing') return;
      
      try {
        this.state = 'ended';
        this.clearAllTimers();

        let winner = 'Berabere';
        if (this.score.p1 > this.score.p2) winner = 'Oyuncu 1';
        else if (this.score.p2 > this.score.p1) winner = 'Oyuncu 2';
        
        this.toast(`üéâ ${winner} kazandƒ±!`, 2000);
        
        this.createTimeout(() => {
          this.menu?.classList.remove('hidden');
          this.ui?.classList.add('hidden');
          this.legend?.classList.add('hidden');
          this.powerIndicator?.classList.add('hidden');
          this.canvas?.classList.add('hidden');
          this.state = 'menu';
        }, 2100);
        
      } catch (e) {
        this.handleError("End game error", e);
      }
    }

    // --- Entity Management ---
    setDifficulty(mode){
      this.difficulty = mode;
      const settings = {
        easy: {speed: 0.7, jump: 0.015, track: 0.8, react: 0.9},
        hard: {speed: 1.7, jump: 0.065, track: 1.5, react: 1.3},
        expert: {speed: 2.0, jump: 0.08, track: 1.8, react: 1.6},
        normal: {speed: 1.2, jump: 0.035, track: 1.1, react: 1.0}
      };
      
      const setting = settings[mode] || settings.normal;
      this.aiSpeed = setting.speed;
      this.aiJumpProb = setting.jump;
      this.aiTrack = setting.track;
      this.aiReact = setting.react;
    }

    resetEntities(){
      if (!this.canvas) return;
      
      const w = this.canvas.width;
      this.player1 = { x: 160, y: 420, vx:0, vy:0, r:40, color:'#00e676', onGround:false, speedMul:1, jumpMul:1, powers:[] };
      this.player2 = { x: w-160, y: 420, vx:0, vy:0, r:40, color:'#ff5252', onGround:false, speedMul:1, jumpMul:1, powers:[] };
      this.ball = { x: w/2, y: 280, vx:0, vy:0, r:15, color:'#ff0', bigUntil:0, frozen:false, onFire:false, lastBounce:0, lastTouchedBy: null };
      this.goals = { left:{ x:0, y:450, w:86, h:150 }, right:{ x:w-86, y:450, w:86, h:150 } };
    }

    setGameRules(){
      this.ball.r = 15;
      this.gravity = 0.5;
      this.friction = 0.85;
      this.bounceDecay = 0.8;
      this.powerUpSpawnRate = 3000;
      
      if (this.gravitySetting === 'low') {
        this.gravity = 0.2;
        if(this.player1) this.player1.jumpMul = 2.0;
        if(this.player2) this.player2.jumpMul = 2.0;
      } else if (this.gravitySetting === 'high') {
        this.gravity = 0.8;
        if(this.player1) this.player1.jumpMul = 0.7;
        if(this.player2) this.player2.jumpMul = 0.7;
      }
    }

    applyTheme(){
      const body = document.body;
      if (!body) return;
      
      const themes = {
        beach: 'linear-gradient(135deg, #FFDD95 0%, #00C2FF 100%)',
        space: 'radial-gradient(50% 50% at 50% 30%, #2a2a72 0%, #000 80%)',
        neon: 'linear-gradient(135deg, #FF006E 0%, #8338EC 50%, #3A86FF 100%)',
        retro: 'linear-gradient(45deg, #f06, #48f, #0f9, #ff0, #f60)',
        stadium: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)'
      };
      
      body.style.background = themes[this.theme] || themes.stadium;
    }

    // --- Update Logic with Safety Checks ---
    update(){
      try {
        if (!this.ctx || !this.canvas) return;
        
        this.tickTime();
        this.handleInput();
        if(this.mode === 'single') this.updateAI();
        this.updatePhysics();
        this.handlePlayerBallCollisions();
        this.checkGoals();
        this.updateParticles();
        this.spawnPowerUps();
        this.checkPowerUpPickup();
        this.updatePowerEffects();
        this.updateBallTrail();
        this.updateScreenShake();
        this.updateActivePowersDisplay();
        
      } catch (e) {
        this.handleError("Update error", e);
      }
    }

    tickTime(){
      try {
        if (!this._lastTime) this._lastTime = performance.now();
        const now = performance.now();
        
        if (now - this._lastTime >= 1000) {
          this.timeLeft = Math.max(0, this.timeLeft - 1);
          if (this.timeEl) this.timeEl.textContent = this.timeLeft;
          this._lastTime = now;
          
          if (this.timeLeft === 0) this.endGame();
        }
      } catch (e) {
        this.handleError("Time tick error", e);
      }
    }
    
    handleInput(){
      if (!this.player1 || !this.player2) return;
      
      try {
        const p1 = this.player1;
        if (this.keys['a']) p1.vx -= 1.2 * (p1.speedMul || 1);
        if (this.keys['d']) p1.vx += 1.2 * (p1.speedMul || 1);
        if (this.keys['w'] && p1.onGround) { 
          p1.vy = -15 * (p1.jumpMul || 1); 
          p1.onGround = false; 
          this.makeDust(p1); 
          Sound.kick(); 
        }

        if (this.mode === 'soccer') {
          const p2 = this.player2;
          if (this.keys['arrowleft']) p2.vx -= 1.2 * (p2.speedMul || 1);
          if (this.keys['arrowright']) p2.vx += 1.2 * (p2.speedMul || 1);
          if (this.keys['arrowup'] && p2.onGround) { 
            p2.vy = -15 * (p2.jumpMul || 1); 
            p2.onGround = false; 
            this.makeDust(p2); 
            Sound.kick(); 
          }
        }

        // Update power effects
        const t = performance.now();
        [this.player1, this.player2].forEach(p => {
          if (!p.powers) p.powers = [];
          p.powers = p.powers.filter(power => t < power.until);
          p.speedMul = 1; 
          p.jumpMul = 1;
          p.powers.forEach(power => {
            if (power.type === 'speed') p.speedMul = Math.max(p.speedMul, 1.6);
            if (power.type === 'jump') p.jumpMul = Math.max(p.jumpMul, 1.7);
          });
        });

        if (this.ball.bigUntil && t > this.ball.bigUntil) { 
          this.ball.r = 15; 
          this.ball.bigUntil = 0; 
        }
      } catch (e) {
        this.handleError("Input handling error", e);
      }
    }

    updateAI(){
      if (!this.player2 || !this.ball) return;
      
      try {
        const ai = this.player2; 
        const b = this.ball;
        const targetX = this.calculateAITarget();
        const diff = targetX - ai.x;
        
        if (Math.abs(diff) > 15) {
          const moveForce = Math.sign(diff) * 0.6 * this.aiTrack * this.aiReact;
          ai.vx += moveForce;
        }

        const ballDist = Math.hypot(b.x - ai.x, b.y - ai.y);
        const shouldJump = this.shouldAIJump(ballDist, b.y, ai);
        if (shouldJump && ai.onGround && Math.random() < this.aiJumpProb * 2) {
          ai.vy = -15 * ai.jumpMul; 
          ai.onGround = false; 
          this.makeDust(ai);
        }
        ai.x = clamp(ai.x, ai.r + 20, this.canvas.width - ai.r - 20);
      } catch (e) {
        this.handleError("AI update error", e);
      }
    }

    calculateAITarget(){
      const b = this.ball;
      const ai = this.player2;
      const goalCenter = this.canvas.width - 43;

      if (b.vx > 0 && b.x > this.canvas.width * 0.6) return b.x;
      if (b.x < this.canvas.width * 0.4) return lerp(ai.x, goalCenter, 0.3);
      return lerp(ai.x, b.x, 0.8);
    }

    shouldAIJump(ballDist, ballHeight, ai){
      const nearBall = ballDist < 120;
      const ballInAir = ballHeight < this.canvas.height - 100;
      const ballComingDown = this.ball.vy > 0;
      return nearBall && (ballInAir || ballComingDown);
    }

    updatePhysics(){
      if (!this.player1 || !this.player2 || !this.ball || !this.canvas) return;
      
      try {
        const floor = this.canvas.height - 50;
        
        // Update players
        [this.player1, this.player2].forEach(p => {
          p.vy += this.gravity;
          p.vx *= this.friction;
          p.x += p.vx; 
          p.y += p.vy;
          
          if (p.y + p.r > floor) { 
            p.y = floor - p.r; 
            p.vy = 0; 
            p.onGround = true; 
          } else {
            p.onGround = false;
          }
          
          if (p.x - p.r < 0) { p.x = p.r; p.vx = 0; }
          if (p.x + p.r > this.canvas.width) { p.x = this.canvas.width - p.r; p.vx = 0; }
        });

        // Update ball
        const ball = this.ball;
        if (!ball.frozen) {
          ball.vy += this.gravity; 
          ball.vx *= 0.995; 
          ball.vy *= 0.995; 
          ball.x += ball.vx; 
          ball.y += ball.vy;
        }
        
        const t = performance.now();
        if (ball.y + ball.r > floor) { 
          ball.y = floor - ball.r; 
          ball.vy *= -this.bounceDecay;
          if (t - ball.lastBounce > 200) { 
            this.puff(ball.x, ball.y + ball.r, ball.color); 
            Sound.bounce(); 
            ball.lastBounce = t; 
          }
        }
        
        if (ball.x - ball.r < 0) { ball.x = ball.r; ball.vx *= -this.bounceDecay; }
        if (ball.x + ball.r > this.canvas.width) { ball.x = this.canvas.width - ball.r; ball.vx *= -this.bounceDecay; }
        if (ball.y - ball.r < 0) { ball.y = ball.r; ball.vy *= -this.bounceDecay; }
      } catch (e) {
        this.handleError("Physics update error", e);
      }
    }

    handlePlayerBallCollisions(){
      if (!this.player1 || !this.player2 || !this.ball) return;
      
      try {
        const players = [this.player1, this.player2];
        
        players.forEach((p, index) => {
          const dx = this.ball.x - p.x;
          const dy = this.ball.y - p.y; 
          const dist = Math.hypot(dx, dy);
          
          if (dist < p.r + this.ball.r) {
            const ang = Math.atan2(dy, dx);
            const tx = p.x + Math.cos(ang) * (p.r + this.ball.r);
            const ty = p.y + Math.sin(ang) * (p.r + this.ball.r);
            this.ball.x = tx; 
            this.ball.y = ty;
            
            const force = 0.34;
            const powerMul = p.powers.some(pow => pow.type === 'speed') ? 1.3 : 1.0;
            this.ball.vx = Math.cos(ang) * force * 20 * powerMul + p.vx * 0.5;
            this.ball.vy = Math.sin(ang) * force * 20 * powerMul + p.vy * 0.5;
            
            this.ball.lastTouchedBy = index + 1;
            
            const t = performance.now();
            if (this.lastHit.player === index + 1 && t - this.lastHit.time < 2000) {
              this.combo[`p${index + 1}`]++;
              if (this.combo[`p${index + 1}`] >= 3) { 
                this.showCombo(index + 1, this.combo[`p${index + 1}`]); 
                Sound.combo(); 
              }
            } else {
              this.combo[`p${index + 1}`] = 1;
            }
            this.lastHit = {player: index + 1, time: t};
            
            this.spark(this.ball.x, this.ball.y, '#fff'); 
            this.screenShake = Math.min(this.screenShake + 3, 8);
            Sound.kick();
          }
        });
      } catch (e) {
        this.handleError("Collision detection error", e);
      }
    }
    
    checkGoals(){
      if (!this.ball || !this.goals || !this.canvas) return;
      
      try {
        const b = this.ball;
        const L = this.goals.left;
        const R = this.goals.right;
        
        if (b.x - b.r < L.w && b.y > L.y && b.vx < 0) {
          if (this.lastScoredPlayer !== 'p2') { 
            this.score.p2++; 
            this.onGoal('Oyuncu 2'); 
            this.lastScoredPlayer = 'p2'; 
          }
        } else if (b.x + b.r > this.canvas.width - R.w && b.y > R.y && b.vx > 0) {
          if (this.lastScoredPlayer !== 'p1') { 
            this.score.p1++; 
            this.onGoal('Oyuncu 1'); 
            this.lastScoredPlayer = 'p1'; 
          }
        } else {
          if (this.lastScoredPlayer && b.x > L.w && b.x < this.canvas.width - R.w) {
            this.lastScoredPlayer = null;
          }
        }
        
        if (this.p1sEl) this.p1sEl.textContent = this.score.p1; 
        if (this.p2sEl) this.p2sEl.textContent = this.score.p2;
        
        // Oyun sadece s√ºre bitince biter
        // if (this.score.p1 >= this.winningScore || this.score.p2 >= this.winningScore) {
        //   this.endGame();
        // }
      } catch (e) {
        this.handleError("Goal check error", e);
      }
    }
    
    onGoal(who){
      Sound.goal();
      this.flash();
      this.toast('GOOOOOOL!', 900);
      this.screenShake = 15;
      this.resetAfterGoal();
      this.combo = {p1: 0, p2: 0};
    }

    resetAfterGoal(){
      if (!this.player1 || !this.player2 || !this.ball || !this.canvas) return;
      
      this.player1.x = 160; 
      this.player1.y = 420; 
      this.player1.vx = 0; 
      this.player1.vy = 0;
      this.player2.x = this.canvas.width - 160; 
      this.player2.y = 420; 
      this.player2.vx = 0; 
      this.player2.vy = 0;
      this.ball.x = this.canvas.width / 2; 
      this.ball.y = 260; 
      this.ball.vx = (Math.random() - 0.5) * 10; 
      this.ball.vy = 0;
      this.ball.frozen = false; 
      this.ball.onFire = false;
      
      this.createTimeout(() => { 
        this.lastScoredPlayer = null; 
      }, 500);
    }

    // --- PowerUps & Effects with Memory Management ---
    spawnPowerUps(){
      try {
        const now = performance.now();
        if (now - this.lastSpawn < this.powerUpSpawnRate) return;
        if (this.powerUps.length >= 2) return;
        
        if (Math.random() < 0.35) {
          const types = ['speed', 'jump', 'bigball'];
          const type = types[Math.floor(Math.random() * types.length)];
          const x = clamp(rand(80, this.canvas.width - 80), 80, this.canvas.width - 80);
          const y = this.canvas.height - 80;
          
          this.powerUps.push({ 
            type, x, y, r: 16, 
            born: now, pulse: 0 
          });
          this.lastSpawn = now;
        }
        
        // Clean old power-ups
        this.powerUps = this.powerUps.filter(p => now - p.born < 12000);
      } catch (e) {
        this.handleError("PowerUp spawn error", e);
        this.powerUps = [];
      }
    }

    checkPowerUpPickup(){
      if (!this.player1 || !this.player2) return;
      
      try {
        const players = [this.player1, this.player2];
        this.powerUps = this.powerUps.filter(p => {
          let taken = false;
          players.forEach(pl => {
            const d = Math.hypot(pl.x - p.x, pl.y - p.y);
            if (d < pl.r + p.r) { 
              this.applyPower(pl, p.type); 
              taken = true; 
            }
          });
          return !taken;
        });
      } catch (e) {
        this.handleError("PowerUp pickup error", e);
      }
    }

    applyPower(pl, type){
      try {
        Sound.power();
        const now = performance.now();
        
        if (type === 'speed') { 
          pl.speedMul = 1.6; 
          pl.powers.push({type: 'speed', until: now + 5000}); 
          this.toast('Hƒ±z!', 550); 
        }
        if (type === 'jump') { 
          pl.jumpMul = 1.7; 
          pl.powers.push({type: 'jump', until: now + 5000}); 
          this.toast('S√ºper Zƒ±plama!', 650); 
        }
        if (type === 'bigball') { 
          this.ball.r = 26; 
          this.ball.bigUntil = now + 5000; 
          this.toast('B√ºy√ºk Top!', 650); 
        }
        this.spark(pl.x, pl.y - 20, '#ffd54f');
      } catch (e) {
        this.handleError("Apply power error", e);
      }
    }

    updatePowerEffects(){
      try {
        this.powerUps.forEach(p => { 
          p.pulse += 0.15; 
        });
      } catch (e) {
        this.handleError("PowerUp effects error", e);
      }
    }

    updateBallTrail(){
      try {
        if (!this.ball) return;
        
        const speed = (this.ball.vx || 0) * (this.ball.vx || 0) + (this.ball.vy || 0) * (this.ball.vy || 0);
        if (speed > 4) {
          this.ballTrail.push({ 
            x: this.ball.x || 0, 
            y: this.ball.y || 0, 
            life: 8 
          });
        }
        
        this.ballTrail = this.ballTrail.filter(t => {
          if (!t) return false;
          t.life--;
          return t.life > 0;
        });
        
        // Memory management
        if (this.ballTrail.length > 15) {
          this.ballTrail.shift();
        }
      } catch (e) {
        this.handleError("Ball trail error", e);
        this.ballTrail = [];
      }
    }

    updateScreenShake(){
      if (this.screenShake > 0) {
        this.screenShake = Math.max(0, this.screenShake - 0.3);
      }
    }

    updateActivePowersDisplay(){
      try {
        const activePowers = [];
        [this.player1, this.player2].forEach((p, i) => {
          if (p.powers) {
            p.powers.forEach(power => {
              if (power.type === 'speed') activePowers.push(`P${i+1}: Hƒ±z`);
              if (power.type === 'jump') activePowers.push(`P${i+1}: Zƒ±plama`);
            });
          }
        });
        
        if (this.ball.bigUntil > performance.now()) {
          activePowers.push('B√ºy√ºk Top');
        }
        
        const text = activePowers.length > 0 ? 
          `Aktif G√º√ßler: ${activePowers.join(' ‚Ä¢ ')}` : 
          'Aktif G√º√ßler: Yok';
        
        if (this.powerIndicator) {
          this.powerIndicator.textContent = text;
        }
      } catch (e) {
        this.handleError("Power display error", e);
      }
    }

    // --- Particles & FX with Memory Management ---
    makeDust(p){ 
      if (p) this.puff(p.x, this.canvas.height - 40, p.color); 
    }
    
    puff(x, y, color){ 
      for (let i = 0; i < 8; i++) { // Reduced particle count
        this.particles.push({
          x: x + rand(-10, 10), 
          y: y + rand(-6, 6), 
          vx: rand(-2, 2), 
          vy: rand(-3, -0.2), 
          life: 20, // Reduced lifetime
          c: color
        }); 
      } 
    }
    
    spark(x, y, color){ 
      for (let i = 0; i < 12; i++) { // Reduced particle count
        this.particles.push({
          x, y, 
          vx: rand(-4, 4), 
          vy: rand(-4, 0), 
          life: 18, // Reduced lifetime
          c: color
        }); 
      } 
    }

    updateParticles(){
      try {
        // Memory management - limit particle count
        if (this.particles.length > 100) {
          this.particles = this.particles.slice(-100);
        }
        
        this.particles = this.particles.filter(p => {
          if (!p) return false;
          
          p.x += p.vx || 0; 
          p.y += p.vy || 0; 
          p.vy = (p.vy || 0) + 0.18; 
          p.life = (p.life || 0) - 1; 
          
          return p.life > 0;
        });
      } catch (e) {
        this.handleError("Particle update error", e);
        this.particles = [];
      }
    }

    flash(){ 
      try {
        const f = document.createElement('div'); 
        f.className = 'flash'; 
        if (this.fxRoot) {
          this.fxRoot.appendChild(f); 
          this.createTimeout(() => {
            if (f.parentNode) f.remove();
          }, 450);
        }
      } catch (e) {
        this.handleError("Flash effect error", e);
      }
    }

    toast(text, ms = 900){
      try {
        const t = document.createElement('div'); 
        t.className = 'toast'; 
        t.textContent = text; 
        if (this.fxRoot) {
          this.fxRoot.appendChild(t);
          this.createTimeout(() => {
            if (t.parentNode) t.remove();
          }, ms);
        }
      } catch (e) {
        this.handleError("Toast error", e);
      }
    }

    showCombo(playerNum, comboCount){
      try {
        const combo = document.createElement('div');
        combo.className = 'combo-indicator';
        combo.textContent = `${comboCount}x COMBO!`;
        combo.style.color = playerNum === 1 ? '#00e676' : '#ff5252';
        if (this.fxRoot) {
          this.fxRoot.appendChild(combo);
          this.createTimeout(() => {
            if (combo.parentNode) combo.remove();
          }, 800);
        }
      } catch (e) {
        this.handleError("Combo display error", e);
      }
    }
    
    // --- Render with Error Handling ---
    render(){
      if (!this.ctx || !this.canvas) return;
      
      try {
        const ctx = this.ctx;
        const W = this.canvas.width;
        const H = this.canvas.height;
        
        ctx.save();
        
        // Screen shake effect
        if (this.screenShake > 0) {
          ctx.translate(
            rand(-this.screenShake, this.screenShake), 
            rand(-this.screenShake, this.screenShake)
          );
        }
        
        this.drawBackground();
        this.drawGoals();
        this.drawBallTrail();
        
        if (this.player1) this.drawSlime(this.player1); 
        if (this.player2) this.drawSlime(this.player2);
        if (this.ball) this.drawBall();
        
        this.drawPowerUps();
        this.drawParticles();
        
        ctx.restore();
      } catch (e) {
        this.handleError("Render error", e);
      }
    }
    
    drawBackground(){
      const ctx = this.ctx;
      const W = this.canvas.width;
      const H = this.canvas.height;
      
      // Sky
      if (this.theme === 'beach') {
        const g = ctx.createLinearGradient(0, 0, 0, H); 
        g.addColorStop(0, '#9be0ff'); 
        g.addColorStop(1, '#ffe29a'); 
        ctx.fillStyle = g; 
        ctx.fillRect(0, 0, W, H);
      } else if (this.theme === 'space') {
        ctx.fillStyle = '#0b0b2b'; 
        ctx.fillRect(0, 0, W, H);
        // Stars
        for (let i = 0; i < 30; i++) { 
          ctx.globalAlpha = 0.65; 
          ctx.fillStyle = '#fff'; 
          ctx.fillRect(((i * 73) % W), ((i * 131) % H) * 0.5 + 10, 2, 2); 
          ctx.globalAlpha = 1; 
        }
      } else {
        ctx.fillStyle = 'rgba(135,206,235, 1)'; 
        ctx.fillRect(0, 0, W, H);
      }
      
      // Ground
      const fieldColor = this.theme === 'space' ? '#123' : '#228B22';
      ctx.fillStyle = fieldColor;
      ctx.fillRect(0, H - 50, W, 50);

      // Field lines
      ctx.strokeStyle = '#fff'; 
      ctx.lineWidth = 3; 
      ctx.setLineDash([10, 10]); 
      ctx.beginPath(); 
      ctx.moveTo(W / 2, 0); 
      ctx.lineTo(W / 2, H - 50); 
      ctx.stroke(); 
      ctx.setLineDash([]);
      
      // Center circle
      ctx.beginPath(); 
      ctx.arc(W / 2, H - 50, 80, 0, Math.PI, true); 
      ctx.stroke();
    }

    drawGoals(){
      const ctx = this.ctx;
      const L = this.goals.left;
      const R = this.goals.right;
      
      ctx.strokeStyle = '#fff'; 
      ctx.lineWidth = 5; 
      
      // Left goal
      ctx.beginPath(); 
      ctx.moveTo(0, L.y); 
      ctx.lineTo(L.w, L.y); 
      ctx.lineTo(L.w, L.y + L.h); 
      ctx.stroke();
      
      // Right goal
      ctx.beginPath(); 
      ctx.moveTo(this.canvas.width, R.y); 
      ctx.lineTo(this.canvas.width - R.w, R.y); 
      ctx.lineTo(this.canvas.width - R.w, R.y + R.h); 
      ctx.stroke();
    }

    drawSlime(p){
      const ctx = this.ctx;
      
      // Body
      ctx.fillStyle = p.color; 
      ctx.beginPath(); 
      ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2); 
      ctx.fill();
      
      // Shine
      ctx.fillStyle = 'rgba(255,255,255,.3)'; 
      ctx.beginPath(); 
      ctx.arc(p.x - p.r * 0.3, p.y - p.r * 0.3, p.r * 0.3, 0, Math.PI * 2); 
      ctx.fill();
      
      // Eyes
      ctx.fillStyle = '#000'; 
      ctx.beginPath(); 
      ctx.arc(p.x - 10, p.y - 10, 5, 0, Math.PI * 2); 
      ctx.arc(p.x + 10, p.y - 10, 5, 0, Math.PI * 2); 
      ctx.fill();
    }

    drawBall(){
      const ctx = this.ctx;
      const b = this.ball; 
      
      // Ball body
      ctx.fillStyle = b.color; 
      ctx.beginPath(); 
      ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2); 
      ctx.fill();
      
      // Shine
      ctx.fillStyle = 'rgba(255,255,255,.4)'; 
      ctx.beginPath(); 
      ctx.arc(b.x - 5, b.y - 5, 3, 0, Math.PI * 2); 
      ctx.fill();
      
      // Pattern
      ctx.strokeStyle = 'rgba(0,0,0,.35)'; 
      ctx.lineWidth = 2; 
      ctx.beginPath(); 
      ctx.arc(b.x, b.y, b.r * 0.7, 0, Math.PI * 2); 
      ctx.moveTo(b.x - b.r * 0.7, b.y); 
      ctx.lineTo(b.x + b.r * 0.7, b.y); 
      ctx.stroke();
    }

    drawBallTrail(){
      if (!this.ballTrail || !this.ctx) return;
      
      this.ballTrail.forEach(t => {
        this.ctx.save();
        this.ctx.globalAlpha = t.life / 8;
        this.ctx.fillStyle = '#fff';
        this.ctx.beginPath();
        this.ctx.arc(t.x, t.y, 3, 0, Math.PI * 2);
        this.ctx.fill();
        this.ctx.restore();
      });
    }

    drawPowerUps(){
      const ctx = this.ctx;
      
      this.powerUps.forEach(p => {
        const pulseSize = 1 + Math.sin(p.pulse) * 0.2;
        let emoji = '‚ö°'; 
        if (p.type === 'jump') emoji = 'ü¶ò'; 
        if (p.type === 'bigball') emoji = 'üéØ';
        
        ctx.save(); 
        ctx.font = `${20 * pulseSize}px system-ui, sans-serif`; 
        ctx.textAlign = 'center'; 
        ctx.textBaseline = 'middle';
        ctx.fillText(emoji, p.x, p.y);
        ctx.restore();
      });
    }

    drawParticles(){
      const ctx = this.ctx;
      
      this.particles.forEach(p => { 
        ctx.save(); 
        ctx.globalAlpha = Math.max(0, p.life / 20); 
        ctx.fillStyle = p.c; 
        ctx.beginPath(); 
        ctx.arc(p.x, p.y, 2, 0, Math.PI * 2); 
        ctx.fill(); 
        ctx.restore(); 
      });
    }

    // --- Input Handling ---
    bindKeys(){
      // BUGFIX: store handler refs so we can remove them in destroy()
      this._onKeyDown = (e) => { this.keys[e.key.toLowerCase()] = true; };
      this._onKeyUp = (e) => { this.keys[e.key.toLowerCase()] = false; };
      window.addEventListener('keydown', this._onKeyDown);
      window.addEventListener('keyup', this._onKeyUp);
    }

    bindUI(){
      const startBtn = document.getElementById('startBtn');
      const modeSelect = document.getElementById('modeSelect');
      const difficultyRow = document.getElementById('difficultyRow');

      if (modeSelect && difficultyRow) {
        const syncDifficultyVisibility = () => {
          const isSinglePlayer = modeSelect.value === 'single';
          difficultyRow.style.display = isSinglePlayer ? 'grid' : 'none';
        };
        modeSelect.addEventListener('change', syncDifficultyVisibility);
        syncDifficultyVisibility(); // Call on init to set initial state
      }

      if (startBtn) {
        startBtn.addEventListener('click', () => {
          try {
            const mode = document.getElementById('modeSelect')?.value || 'soccer';
            const gravity = document.getElementById('gravitySelect')?.value || 'normal';
            const difficulty = document.getElementById('difficultySelect')?.value || 'normal';
            const theme = document.getElementById('themeSelect')?.value || 'stadium';
            this.start(mode, gravity, difficulty, theme);
          } catch (e) {
            this.handleError("Start button error", e);
          }
        });
      }
      
      const pauseBtn = document.getElementById('pauseBtn');
      if (pauseBtn) {
        pauseBtn.addEventListener('click', () => {
          try {
            this.togglePause();
          } catch (e) {
            this.handleError("Pause button error", e);
          }
        });
      }
      
      const restartBtn = document.getElementById('restartBtn');
      if (restartBtn) {
        restartBtn.addEventListener('click', () => {
          try {
            this.restart();
          } catch (e) {
            this.handleError("Restart button error", e);
          }
        });
      }
      
      // Touch controls with error handling
      const bindTouch = (id, key) => {
        const el = document.getElementById(id);
        if (el) {
          el.addEventListener('touchstart', e => { 
            try {
              e.preventDefault(); 
              this.keys[key] = true; 
            } catch (err) {
              this.handleError("Touch start error", err);
            }
          });
          
          el.addEventListener('touchend', e => { 
            try {
              e.preventDefault(); 
              this.keys[key] = false; 
            } catch (err) {
              this.handleError("Touch end error", err);
            }
          });
        }
      };
      
      bindTouch('p1Left', 'a');
      bindTouch('p1Right', 'd');
      bindTouch('p1Jump', 'w');
    }

    resizeForMobile(){
      try {
        const isMobile = window.innerWidth < 768;
        
        if (this.canvas) {
          if (isMobile) {
            this.canvas.width = Math.min(window.innerWidth * 0.95, 800);
            this.canvas.height = Math.min(window.innerHeight * 0.7, 500);
          } else {
            this.canvas.width = 960;
            this.canvas.height = 600;
          }
        }
        
        if (this.touchpad) {
          if (isMobile) {
            this.touchpad.classList.remove('hidden');
          } else {
            this.touchpad.classList.add('hidden');
          }
        }
        
        this.resetEntities();
      } catch (e) {
        this.handleError("Resize error", e);
      }
    }

    // --- Cleanup Methods ---
    destroy() {
      try {
        this.clearAllTimers();
        
        // Remove event listeners we attached
        if (this._onKeyDown) window.removeEventListener('keydown', this._onKeyDown);
        if (this._onKeyUp) window.removeEventListener('keyup', this._onKeyUp);
        if (this._onVisibilityChange) document.removeEventListener('visibilitychange', this._onVisibilityChange);
        
        // Clear references
        this.canvas = null;
        this.ctx = null;
        this.particles = [];
        this.ballTrail = [];
        this.powerUps = [];
        
        console.log("Game destroyed successfully");
      } catch (e) {
        console.error("Error during cleanup:", e);
      }
    }
  }

  // --- Bootstrap with Enhanced Error Handling ---
  let game = null;
  
  function initializeGame() {
    try {
      // Clean up existing game
      if (game) {
        game.destroy();
      }
      
      // Create new game instance
      game = new Game();
      window.game = game; // For debugging
      
      console.log("Game initialized successfully");
    } catch (e) {
      console.error("Failed to initialize game:", e);
      
      // Show error message to user
      const errorEl = document.getElementById('errorMessage');
      if (errorEl) {
        errorEl.textContent = 'Oyun ba≈ülatƒ±lamadƒ±. Sayfa yenileyin.';
        errorEl.style.display = 'block';
      }
    }
  }

  // Initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeGame);
  } else {
    initializeGame();
  }
  
  // Handle window resize
  window.addEventListener('resize', () => {
    if (game) {
      try {
        game.resizeForMobile();
      } catch (e) {
        console.error("Resize handler error:", e);
      }
    }
  });
  
  // Handle page unload
  window.addEventListener('beforeunload', () => {
    if (game) {
      game.destroy();
    }
  });
  
  // Error recovery - restart game if too many errors
  window.addEventListener('error', (e) => {
    console.error("Global error:", e);
    if (game && game.errorCount >= game.maxErrors) {
      console.warn("Restarting game due to excessive errors");
      setTimeout(initializeGame, 1000);
    }
  });
  </script>
</body>
</html>
